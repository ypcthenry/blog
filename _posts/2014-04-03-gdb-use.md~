---
layout: default
title: 我的日常工具——gdb篇
---
<h2>{{ page.title }}</h2>
<p>{{ page.date | date_to_string }}</p>


***
**1.gdb的原理**
熟悉linux的同学面试官会问你用过gdb么？那好用过，知道gdb是怎么工作的么？然后直接傻眼。。。
gdb是怎么接管一个进程？并且能获取这个进程的变量、堆栈、寄存器、内存映像等信息的呢？还可以打断点执行？这些都是gdb一些基本的功能。
很简单，ptrace，好来看看[manual][1]上这个系统调用的定义。
```c
#include <sys/ptrace.h>
long ptrace(enum __ptrace_request request, pid_t pid,void *addr, 
                    void *data);
```
*简单描述：*
`ptrace系统调用提供一种方法使某一父进程(叫做"tracer")可以观察并控制另外一个进程(叫做"tracee")的执行，而且还可以检查并改变执行tracee进程时的内存映像和寄存器。这个系统调用主要用来实现断点调试和函数调用跟踪（ It is primarily used to implement breakpoint debugging and system call tracing）。`

**2.gdb将高级语言转成汇编**
对于c、c++这样的语言，如果不注意内存释放经常会出现“野指针”、“空指针”等，程序dump掉的时候要找清楚那地方crash了，汇编指令显的非常重要。
比如：
 `程序1：`
```c
#include <stdio.h>
struct foo{
    int i;
    char a[0];
};
struct fool{
    struct foo *henry;
};
int main()
{
    struct fool test={0};
    if(test.henry->a)
        printf("%x\n",test.henry->a);
    return 0;
}
    
```
`程序2：`
```c
#include <stdio.h>
struct foo{
    int i;
    char *a;
};
struct fool{
    struct foo *henry;
};
int main()
{
    struct fool test={0};
    if(test.henry->a)
        printf("%x\n",test.henry->a);
    return 0;
}
```
第一个程序不会core dump，而第二个程序core dump掉了。原因在第12行程序1访问的a是数组的地址，而程序2访问的时指针a的内容，a为`NULL`指针，访问其内容当然时非法的。你可能要问了，你为什么知道程序1访问的是地址而程序2访问的是内容呢？
那就需要汇编指令帮忙了。

    题外话：程序2dump会产生core文件，如果没有出现core文件，用ulimit -c unlimited命令产生。

<!-- UY BEGIN -->
<div>
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js"></script>
<!-- UY END -->
</div>
<hr/>
<div style="margin-left:0px;margin-right:0px">
<div style="float:left"><a href="http://www.danasoft.com"><img src="http://www.danasoft.com/vipersig.jpg" border="0"></a></div>
<div style="float:right;margin-right:200px">Copyright &copy; 2014 Ypchenry ,Hosted by <a href="https://github.com" style="text-decoration:none">GitHub</a></div>
</div>
